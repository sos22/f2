#ifndef CONNPOOL_TMPL__
#define CONNPOOL_TMPL__

#ifndef CONNPOOL_H__
#error Include connpool.H before connpool.tmpl
#endif

#include "maybe.tmpl"

template <typename t> class connpool::asynccallT final {
    friend class connpool;
private: asynccall *inner;
private: maybe<orerror<t> > res;
private: asynccallT() : inner(NULL), res(Nothing) { }
public:  class token {
        friend class asynccallT<t>;
    private: asynccall::token inner;
    private: explicit token(asynccall::token _inner) : inner(_inner) {}; };
public:  maybe<token> finished() const {
        auto r(inner->finished());
        if (r.isjust()) return token(r.just());
        else return Nothing; }
public:  orerror<t> pop(token tok) {
    assert(res.isjust());

    /* Ignore result, just doing it to release the inner structure. */
    inner->pop(tok.inner);

    auto r(res.just());
    delete this;
    return r; }
public:  const publisher &pub() const { return inner->pub(); }
public:  orerror<t> abort() {
        inner->abort();
        auto r(res.just());
        delete this;
        return r; }
public:  token finished(clientio io) const { return token(inner->finished(io));}
public:  orerror<t> pop(clientio io) { return pop(finished(io)); }
private: ~asynccallT() { } };

template <typename t> nnp<connpool::asynccallT<t> >
connpool::_call(
    const agentname &sn,
    interfacetype type,
    maybe<timestamp> deadline,
    const std::function<serialise> &s,
    const deserialiserT<t> &ds) {
    auto res(new asynccallT<t>());
    res->inner = call(
        sn,
        type,
        deadline,
        s,
        [ds, res]
        (asynccall &, orerror<nnp<deserialise1> > ds2, connlock cl)
            -> orerror<void> {
            /* Careful: res->inner might not have been set yet. */
            res->res.mkjust(ds.inner(*res, ds2, cl));
            if (res->res.just().isfailure()) return res->res.just().failure();
            else return Success; });
    return _nnp(*res); }

template <typename t> orerror<t>
connpool::_call(
    clientio io,
    const agentname &sn,
    interfacetype type,
    maybe<timestamp> deadline,
    const std::function<serialise> &s,
    const deserialiserT<t> &ds) {
    return _call<t>(sn, type, deadline, s, ds)->pop(io); }

#endif /* !CONNPOOL_TMPL__ */
