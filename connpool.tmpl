#ifndef CONNPOOL_TMPL__
#define CONNPOOL_TMPL__

#ifndef CONNPOOL_H__
#error Include connpool.H before connpool.tmpl
#endif

#include "maybe.tmpl"

template <typename t>
connpool::deserialiserT<t>::deserialiserT(const std::function<orerror<t> (
                                              orerror<nnp<deserialise1> >,
                                              connlock) > &_inner)
    : inner([_inner]
            (asynccallT<t> &, orerror<nnp<deserialise1> > ds, connlock cl) {
                return _inner(ds, cl); }) {}

template <typename t>
connpool::asynccallT<t>::asynccallT() : inner(NULL), res(Nothing) {}

template <typename t> maybe<typename connpool::asynccallT<t>::token>
connpool::asynccallT<t>::finished() const {
    auto r(inner->finished());
    if (r.isjust()) return token(r.just());
    else return Nothing; }

template <typename t> orerror<t>
connpool::asynccallT<t>::pop(token tok) {
    assert(res.isjust());
    /* Ignore result, just doing it to release the inner structure. */
    inner->pop(tok.inner);
    auto r(res.just());
    delete this;
    return r; }

template <typename t> const publisher &
connpool::asynccallT<t>::pub() const { return inner->pub(); }

template <typename t> orerror<t>
connpool::asynccallT<t>::abort() {
    inner->abort();
    auto r(res.just());
    delete this;
    return r; }

template <typename t> typename connpool::asynccallT<t>::token
connpool::asynccallT<t>::finished(clientio io) const {
    return token(inner->finished(io)); }

template <typename t> orerror<t>
connpool::asynccallT<t>::pop(clientio io) { return pop(finished(io)); }

template <typename t> nnp<connpool::asynccallT<t> >
connpool::_call(
    const agentname &sn,
    interfacetype type,
    maybe<timestamp> deadline,
    const std::function<serialise> &s,
    const deserialiserT<t> &ds) {
    auto res(new asynccallT<t>());
    res->inner = call(
        sn,
        type,
        deadline,
        s,
        [ds, res]
        (asynccall &, orerror<nnp<deserialise1> > ds2, connlock cl)
            -> orerror<void> {
            /* Careful: res->inner might not have been set yet. */
            res->res.mkjust(ds.inner(*res, ds2, cl));
            if (res->res.just().isfailure()) return res->res.just().failure();
            else return Success; });
    return _nnp(*res); }

template <typename t> orerror<t>
connpool::_call(
    clientio io,
    const agentname &sn,
    interfacetype type,
    maybe<timestamp> deadline,
    const std::function<serialise> &s,
    const deserialiserT<t> &ds) {
    return _call<t>(sn, type, deadline, s, ds)->pop(io); }

#endif /* !CONNPOOL_TMPL__ */
