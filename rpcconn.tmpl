#ifndef RPCCONN_TMPL__
#define RPCCONN_TMPL__

#include "beaconclient.H"
#include "fields.H"
#include "logging.H"
#include "proto.H"
#include "peername.H"
#include "rpcconn.H"
#include "socket.H"
#include "tcpsocket.H"

#include "orerror.tmpl"
#include "thread.tmpl"
#include "waitbox.tmpl"

template <typename t> rpcconn::postedcall &
rpcconn::postedcall::addparam(wireproto::parameter<t> tmpl, const t &what) {
    resp.addparam(tmpl, what);
    return *this; }

template <typename conn_t, typename... args> orerror<conn_t *>
rpcconn::fromsocket(socket_t sock,
                    const rpcconnconfig &config,
                    args &&... parameters) {
    auto peer(sock.peer());
    if (peer.isfailure()) return peer.failure();
    else return thread::_spawn<conn_t, rpcconntoken, args...>(
        "IO:"+fields::mk(peer.success()),
        [sock, &config, &peer] (const thread::constoken &inner) {
            return rpcconntoken(inner, sock, config, peer.success()); },
        std::forward<args>(parameters)...)
             .go(); }

template <typename conn_t, typename ... args> orerror<conn_t *>
rpcconn::connect(clientio io,
                 const peername &p,
                 const rpcconnconfig &config,
                 args &&... parameters) {
    /* XXX send version number */
    auto s(tcpsocket::connect(io, p));
    if (s.isfailure()) return s.failure();
    auto r(fromsocket<conn_t>(
               s.success(),
               config,
               std::forward<args>(parameters)...));
    if (r.isfailure()) s.success().close();
    return r; }

#endif /* !RPCCONN_TMPL__ */
