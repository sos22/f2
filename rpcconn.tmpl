#ifndef RPCCONN_TMPL__
#define RPCCONN_TMPL__

#include "beaconclient.H"
#include "fields.H"
#include "logging.H"
#include "proto.H"
#include "peername.H"
#include "rpcconn.H"
#include "socket.H"
#include "tcpsocket.H"
#include "thread.H"

#include "waitbox.tmpl"

template <typename conn_t, typename... args> orerror<conn_t *>
rpcconn::fromsocket(socket_t sock,
                    const rpcconnauth &auth,
                    args... parameters) {
    auto peer(sock.peer());
    if (peer.isfailure()) return peer.failure();
    auto res(new conn_t(sock,
                        auth,
                        peer.success(),
                        parameters...));
    auto spawnres(thread::spawn(res, &res->thr,
                                "IO:"+fields::mk(peer.success())));
    if (spawnres.isjust()) {
        delete res;
        return spawnres.just(); }
    return res; }

template <typename conn_t, typename... args> orerror<conn_t *>
rpcconn::connectmaster(clientio io,
                       const beaconresult &br,
                       args ... parameters) {
    /* No need to authenticate: we assume that the caller has already
       done enough to check that the peername is correct (that is the
       point of beacon protocol, after all) and the crypto isn't
       strong enough to do more than that anyway. */
    auto res(connect<conn_t>(io,
                             rpcconnauth::mkdone(),
                             br.mastername,
                             parameters...));
    if (res.isfailure()) return res.failure();
    auto conn(res.success());
    auto hellores(conn->call(
                      io,
                      wireproto::req_message(proto::HELLO::tag,
                                             conn->allocsequencenr())
                      .addparam(proto::HELLO::req::version, 1u)
                      .addparam(proto::HELLO::req::nonce, br.nonce)
                      .addparam(proto::HELLO::req::slavename,
                                br.slavename)
                      .addparam(proto::HELLO::req::digest,
                                digest("B" +
                                       fields::mk(br.nonce) +
                                       fields::mk(br.secret)))));
    if (hellores.isfailure()) {
        conn->destroy(io);
        return hellores.failure(); }
    logmsg(loglevel::notice,
           "connected to master at " + fields::mk(br.mastername));
    return conn; }

template <typename conn_t, typename ... args> orerror<conn_t *>
rpcconn::connectslave(clientio io,
                      const peername &peer,
                      const registrationsecret &rs,
                      args ... parameters) {
    waitbox<maybe<error> > wb;
    auto res(connect<conn_t>(io,
                             rpcconnauth::mkwaithelloslavea(rs, &wb),
                             peer,
                             parameters...));
    if (res.isfailure()) return res.failure();
    auto r(wb.get());
    if (r.isjust()) {
        res.success()->destroy(io);
        return r.just(); }
    return res.success(); }

template <typename conn_t, typename ... args> orerror<conn_t *>
rpcconn::connect(clientio io,
                 const rpcconnauth &auth,
                 const peername &p,
                 args ... parameters) {
    auto s(tcpsocket::connect(io, p));
    if (s.isfailure()) return s.failure();
    auto r(fromsocket<conn_t>(
               s.success(),
               auth,
               parameters...));
    if (r.isfailure()) s.success().close();
    return r; }

#endif /* !RPCCONN_TMPL__ */
