#ifndef LIST_TMPL__
#define LIST_TMPL__

#include <stdlib.h>

#define containerof(_ptr, _type, _member)				\
    ((_type *)((unsigned long)(_ptr) - (unsigned long)&((_type *)0)->_member))

template <typename t> struct list<t>::member {
    nub linkage;
    t value;
    member(const t &v)
	: value(v)
	{}
    member()
	: value()
	{}
};

template <typename t>
list<t>::list()
{
    root.next = root.prev = containerof(&root, member, linkage);
}

template <typename t>
list<t>::~list()
{
    assert(empty());
}

template <typename t> void
list<t>::flush()
{
    auto i(start());
    while (!i.finished())
	i.remove();
}

template <typename t> bool
list<t>::empty() const
{
    return &root.next->linkage == &root;
}

template <typename t> t
list<t>::pop()
{
    assert(!empty());
    auto i(start());
    t res = *i;
    i.remove();
    return res;
}

template <typename t> void
list<t>::push(const t &what)
{
    auto m(new member(what));
    m->linkage.next = root.next;
    m->linkage.prev = containerof(&root, member, linkage);
    root.next->linkage.prev = m;
    root.next = m;
}

template <typename t> t *
list<t>::tail()
{
    if (empty())
	return NULL;
    else
	return &root.prev->value;
}

template <typename t> t *
list<t>::head()
{
    if (empty())
	return NULL;
    else
	return &root.next->value;
}

template <typename t> t *
list<t>::append()
{
    auto m(new member());
    m->linkage.prev = root.prev;
    m->linkage.next = containerof(&root, member, linkage);
    root.prev->linkage.next = m;
    root.prev = m;
    return &m->value;
}

template <typename t> t *
list<t>::prepend()
{
    auto m(new member());
    m->linkage.next = root.next;
    m->linkage.prev = containerof(&root, member, linkage);
    root.next->linkage.prev = m;
    root.next = m;
    return &m->value;
}

template <typename t> typename list<t>::iter
list<t>::start()
{
    return list<t>::iter(root.next, root.next->linkage.next, &root);
}

template <typename t> bool
list<t>::iter::finished() const
{
    return &cursor->linkage == eof;
}

template <typename t>
list<t>::iter::iter(member *_cursor,
		    member *_n,
		    nub *_eof)
    : cursor(_cursor), n(_n), eof(_eof)
{}

template <typename t> void
list<t>::iter::next()
{
    assert(!finished());
    cursor = n;
    n = cursor->linkage.next;
}

template <typename t> t &
list<t>::iter::operator*()
{
    assert(!finished());
    return cursor->value;
}

template <typename t> t *
list<t>::iter::operator->()
{
    assert(!finished());
    return &cursor->value;
}

template <typename t> const t &
list<t>::iter::operator*() const
{
    assert(!finished());
    return cursor->value;
}

template <typename t> const t *
list<t>::iter::operator->() const
{
    assert(!finished());
    return &cursor->value;
}

template <typename t> void
list<t>::iter::remove()
{
    assert(!finished());
    cursor->linkage.next->linkage.prev = cursor->linkage.prev;
    cursor->linkage.prev->linkage.next = cursor->linkage.next;
    delete cursor;
    next();
}

template <typename t> typename list<t>::const_iter
list<t>::start() const
{
    return list<t>::const_iter(root.next, root.next->linkage.next, &root);
}

template <typename t> bool
list<t>::const_iter::finished() const
{
    return &cursor->linkage == eof;
}

template <typename t>
list<t>::const_iter::const_iter(const member *_cursor,
				const member *_n,
				const nub *_eof)
    : cursor(_cursor), n(_n), eof(_eof)
{}

template <typename t> void
list<t>::const_iter::next()
{
    assert(!finished());
    cursor = n;
    n = cursor->linkage.next;
}

template <typename t> const t &
list<t>::const_iter::operator*() const
{
    assert(!finished());
    return cursor->value;
}

template <typename t> const t *
list<t>::const_iter::operator->() const
{
    assert(!finished());
    return &cursor->value;
}

#endif /* !LIST_TMPL__ */
