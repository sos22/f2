#ifndef LIST_TMPL__
#define LIST_TMPL__

#include <stdlib.h>

template <typename t> struct list<t>::member {
    member *next;
    member *prev;
    t value;
    member(const member &) = delete;
    void operator=(const member &) = delete;
    member(member *_next, member *_prev, const t &v)
        : next(_next), prev(_prev), value(v)
        {}
    member(member *_next, member *_prev)
        : next(_next), prev(_prev), value()
        {}
};

template <typename t>
list<t>::list()
    : head(NULL), tail(NULL)
{
}

template <typename t>
list<t>::~list()
{
    assert(empty());
}

template <typename t> void
list<t>::flush()
{
    auto i(start());
    while (!i.finished())
        i.remove();
}

template <typename t> bool
list<t>::empty() const
{
    assert(!head == !tail);
    return !head;
}

template <typename t> t
list<t>::pophead()
{
    assert(!empty());
    auto i(start());
    t res = *i;
    i.remove();
    return res;
}

template <typename t> t
list<t>::poptail()
{
    assert(!empty());
    auto i(reverse());
    t res = *i;
    i.remove();
    return res;
}

template <typename t> void
list<t>::pushhead(const t &what)
{
    auto m(new member(head, NULL, what));
    if (head) {
        assert(tail);
        head->prev = m;
    } else {
        assert(!tail);
        tail = m;
    }
    head = m;
}

template <typename t> void
list<t>::pushtail(const t &what)
{
    auto m(new member(NULL, tail, what));
    if (tail) {
        assert(head);
        tail->next = m;
    } else {
        assert(!head);
        head = m;
    }
    tail = m;
}

template <typename t> t &
list<t>::append()
{
    auto m(new member(NULL, tail));
    if (tail) {
        assert(head);
        tail->next = m;
    } else {
        assert(!head);
        head = m;
    }
    tail = m;
    return m->value;
}

template <typename t> t &
list<t>::prepend()
{
    auto m(new member(head, NULL));
    if (head) {
        assert(tail);
        head->prev = m;
    } else {
        assert(!tail);
        tail = m;
    }
    head = m;
    return m->value;
}

template <typename t> typename list<t>::iter
list<t>::start()
{
    return list<t>::iter(this, false);
}

template <typename t> typename list<t>::iter
list<t>::reverse()
{
    return list<t>::iter(this, true);
}

template <typename t> bool
list<t>::iter::finished() const
{
    return cursor == NULL;
}

template <typename t>
list<t>::iter::iter(list *_owner,
                    bool _reverse)
    : owner(_owner),
      cursor(_reverse
             ? owner->tail
             : owner->head),
      reverse(_reverse)
{}

template <typename t> void
list<t>::iter::next()
{
    assert(!finished());
    cursor = reverse
        ? cursor->prev
        : cursor->next;
}

template <typename t> t &
list<t>::iter::operator*()
{
    assert(!finished());
    return cursor->value;
}

template <typename t> t *
list<t>::iter::operator->()
{
    assert(!finished());
    return &cursor->value;
}

template <typename t> const t &
list<t>::iter::operator*() const
{
    assert(!finished());
    return cursor->value;
}

template <typename t> const t *
list<t>::iter::operator->() const
{
    assert(!finished());
    return &cursor->value;
}

template <typename t> void
list<t>::iter::remove()
{
    assert(!finished());
    member *n = reverse
        ? cursor->prev
        : cursor->next;
    if (cursor->next) {
        cursor->next->prev = cursor->prev;
    } else {
        assert(cursor == owner->tail);
        owner->tail = cursor->prev;
    }
    if (cursor->prev) {
        cursor->prev->next = cursor->next;
    } else {
        assert(cursor == owner->head);
        owner->head = cursor->next;
    }
    delete cursor;
    cursor = n;
}

template <typename t> typename list<t>::const_iter
list<t>::start() const
{
    return list<t>::const_iter(this, false);
}

template <typename t> bool
list<t>::const_iter::finished() const
{
    return cursor == NULL;
}

template <typename t>
list<t>::const_iter::const_iter(const list *_owner,
                                bool _reverse)
    : owner(_owner),
      cursor(_reverse
             ? _owner->tail
             : _owner->head),
      reverse(_reverse)
{}

template <typename t> void
list<t>::const_iter::next()
{
    assert(!finished());
    cursor = reverse
        ? cursor->prev
        : cursor->next;
}

template <typename t> const t &
list<t>::const_iter::operator*() const
{
    assert(!finished());
    return cursor->value;
}

template <typename t> const t *
list<t>::const_iter::operator->() const
{
    assert(!finished());
    return &cursor->value;
}

template <typename t> int
list<t>::length() const
{
    int res;
    res = 0;
    for (auto it(start()); !it.finished(); it.next())
        res++;
    return res;
}

template <typename t> void
list<t>::sanitycheck() const
{
    const member *cursor1;
    const member *cursor2;

    cursor1 = head;
    if (cursor1 == tail) {
        assert(!cursor1 || !cursor1->next);
        return;
    }
    assert(cursor1);
    assert(!cursor1->prev);
    /* Cursor1 advances twice as fast as cursor2, to check for
     * cycles. */
    cursor2 = head;
    while (1) {
        cursor1 = cursor1->next;
        assert(cursor1);
        assert((cursor1->next == NULL) == (cursor1 == tail));
        assert((cursor1->prev == NULL) == (cursor1 == head));
        assert(!cursor1->next || cursor1->next->prev == cursor1);
        assert(!cursor1->prev || cursor1->prev->next == cursor1);
        if (cursor1 == tail)
            break;
        assert(cursor1 != cursor2);
        cursor1 = cursor1->next;
        assert(cursor1);
        assert((cursor1->next == NULL) == (cursor1 == tail));
        assert((cursor1->prev == NULL) == (cursor1 == head));
        assert(!cursor1->next || cursor1->next->prev == cursor1);
        assert(!cursor1->prev || cursor1->prev->next == cursor1);
        if (cursor1 == tail)
            break;
        cursor2 = cursor2->next;
    }
}

#endif /* !LIST_TMPL__ */
