#ifndef LIST_TMPL__
#define LIST_TMPL__

#include <stdlib.h>

#define containerof(_ptr, _type, _member)				\
    ((_type *)((unsigned long)(_ptr) - (unsigned long)&((_type *)0)->_member))

template <typename t> struct list<t>::member {
    nub linkage;
    t value;
    member(const t &v)
	: value(v)
	{}
    member()
	: value()
	{}
};

template <typename t>
list<t>::list()
{
    root.next = root.prev = containerof(&root, member, linkage);
}

template <typename t>
list<t>::~list()
{
    assert(empty());
}

template <typename t> void
list<t>::flush()
{
    auto i(start());
    while (!i.finished())
	i.remove();
}

template <typename t> bool
list<t>::empty() const
{
    return &root.next->linkage == &root;
}

template <typename t> t
list<t>::pophead()
{
    assert(!empty());
    auto i(start());
    t res = *i;
    i.remove();
    return res;
}

template <typename t> t
list<t>::poptail()
{
    assert(!empty());
    auto i(reverse());
    t res = *i;
    i.remove();
    return res;
}

template <typename t> void
list<t>::pushhead(const t &what)
{
    auto m(new member(what));
    m->linkage.next = root.next;
    m->linkage.prev = containerof(&root, member, linkage);
    root.next->linkage.prev = m;
    root.next = m;
}

template <typename t> void
list<t>::pushtail(const t &what)
{
    auto m(new member(what));
    m->linkage.prev = root.prev;
    m->linkage.next = containerof(&root, member, linkage);
    root.prev->linkage.next = m;
    root.prev = m;
}

template <typename t> t &
list<t>::append()
{
    auto m(new member());
    m->linkage.prev = root.prev;
    m->linkage.next = containerof(&root, member, linkage);
    root.prev->linkage.next = m;
    root.prev = m;
    return m->value;
}

template <typename t> t &
list<t>::prepend()
{
    auto m(new member());
    m->linkage.next = root.next;
    m->linkage.prev = containerof(&root, member, linkage);
    root.next->linkage.prev = m;
    root.next = m;
    return m->value;
}

template <typename t> typename list<t>::iter
list<t>::start()
{
    return list<t>::iter(&root, false);
}

template <typename t> typename list<t>::iter
list<t>::reverse()
{
    return list<t>::iter(&root, true);
}

template <typename t> bool
list<t>::iter::finished() const
{
    return &cursor->linkage == eof;
}

template <typename t>
list<t>::iter::iter(nub *_eof,
		    bool _reverse)
    : cursor(_reverse
	     ? _eof->prev
	     : _eof->next),
      n(_reverse
	? cursor->linkage.prev
	: cursor->linkage.next),
      eof(_eof),
      reverse(_reverse)
{}

template <typename t> void
list<t>::iter::next()
{
    assert(!finished());
    cursor = n;
    if (reverse)
	n = cursor->linkage.prev;
    else
	n = cursor->linkage.next;
}

template <typename t> t &
list<t>::iter::operator*()
{
    assert(!finished());
    return cursor->value;
}

template <typename t> t *
list<t>::iter::operator->()
{
    assert(!finished());
    return &cursor->value;
}

template <typename t> const t &
list<t>::iter::operator*() const
{
    assert(!finished());
    return cursor->value;
}

template <typename t> const t *
list<t>::iter::operator->() const
{
    assert(!finished());
    return &cursor->value;
}

template <typename t> void
list<t>::iter::remove()
{
    assert(!finished());
    cursor->linkage.next->linkage.prev = cursor->linkage.prev;
    cursor->linkage.prev->linkage.next = cursor->linkage.next;
    delete cursor;
    next();
}

template <typename t> typename list<t>::const_iter
list<t>::start() const
{
    return list<t>::const_iter(&root, false);
}

template <typename t> bool
list<t>::const_iter::finished() const
{
    return &cursor->linkage == eof;
}

template <typename t>
list<t>::const_iter::const_iter(const nub *_eof,
				bool _reverse)
    : cursor(_reverse
	     ? _eof->prev
	     : _eof->next),
      eof(_eof),
      reverse(_reverse)
{}

template <typename t> void
list<t>::const_iter::next()
{
    assert(!finished());
    cursor = reverse
	? cursor->linkage.prev
	: cursor->linkage.next;
}

template <typename t> const t &
list<t>::const_iter::operator*() const
{
    assert(!finished());
    return cursor->value;
}

template <typename t> const t *
list<t>::const_iter::operator->() const
{
    assert(!finished());
    return &cursor->value;
}

#endif /* !LIST_TMPL__ */
