/* Local queues.  Like event queues, but specialised for intra-process
 * communication, just because that gives us a slightly easier API.
 * There are two interesting classes: the source and the destination.
 * Like an event queue, things only disappear from the source once
 * they've been released out of every destination.  Unlike an event
 * queue, lqueues never drop things in response to a slow receiver;
 * the queue instead grows without bounds.  This only makes sense if
 * the destination can keep up with the source, so we produce a
 * warning if events have been waiting too long. */
#ifndef LQUEUE_H__
#define LQUEUE_H__

#include "list.H"
#include "maybe.H"
#include "mutex.H"
#include "pubsub.H"
#include "timedelta.H"
#include "timestamp.H"

template <typename> class evtsrc;
template <typename> class evtdest;
class genevtdest;
class genevtsrc;

/* Implementation detail of evtsrc. */
class genevtsrc {
private: genevtsrc(const genevtsrc &) = delete;
private: void operator=(const genevtsrc &) = delete;
public: struct slot {
    unsigned long idx;
    slot *next;
    timestamp pushedat;
    unsigned char inner[0]; };
public: slot *head;
public: slot *tail;
public: mutex_t mux;
public: list<genevtdest *> dests;
public: unsigned long sequence;
public: publisher pub;
public: const size_t sz;
public: const timedelta maxwait;
public: genevtsrc(size_t sz, timedelta maxwait);
public: bool push(slot &);
public: ~genevtsrc(); };

/* An lqueue event src whose events are of type evt.  The event
 * type must have a simple copy constructor. */
template <typename evt> class evtsrc : private genevtsrc {
    friend class evtdest<evt>;
public:  explicit evtsrc(timedelta _maxwait)
    : genevtsrc(sizeof(evt), _maxwait) {}
    /* Add an event to the queue.  It gets removed again as soon as
     * all of the queues have pop()ed it out. */
public:  void push(const evt &_evt) {
    if (dests.empty_unsafe()) return;
    auto slt((slot *)malloc(sizeof(slot) + sizeof(evt)));
    new (slt->inner) evt(_evt);
    if (!genevtsrc::push(*slt)) {
        (*(evt *)slt->inner).~evt();
        free(slt); } } };

/* Implementation detail of evtdest */
class genevtdest {
private: genevtdest() = delete;
private: genevtdest(const genevtdest &) = delete;
private: void operator=(const genevtdest &) = delete;
public:  unsigned long sequence;
public:  genevtsrc &src;
public:  explicit genevtdest(genevtsrc &);
public:  genevtsrc::slot *startpop();
public:  bool finishpop(genevtsrc::slot &);
public:  genevtsrc::slot *unsubscribe(); };

/* An lqueue event destination.  Once the evtdest is subscribed to a
 * source (i.e. once its constructor returns) it receives every event
 * generated by the source.  The destination must be torn down before
 * the source. */
template <typename evt> class evtdest : private genevtdest {
    friend class evtsrc<evt>;
public: explicit evtdest(evtsrc<evt> &d) : genevtdest(d) {}
public: const publisher &pub() const { return src.pub; }
public: maybe<evt> pop() {
    auto s(genevtdest::startpop());
    if (s == NULL) return Nothing;
    auto res(*(evt *)s->inner);
    if (genevtdest::finishpop(*s)) {
        (*(evt *)s->inner).~evt();
        free(s); }
    return res; }
public: evt pop(clientio io) {
    auto r(pop());
    if (r == Nothing) {
        subscriber sub;
        subscription ss(sub, pub());
        r = pop();
        while (r == Nothing) {
            sub.wait(io);
            r = pop(); } }
    return r.just(); }
public: ~evtdest() {
    auto it(unsubscribe());
    while (it != NULL) {
        auto n(it->next);
        (*(evt *)it->inner).~evt();
        free(it);
        it = n; } } };

namespace tests { void _lqueue(); }

#endif /* !LQUEUE_H__ */
