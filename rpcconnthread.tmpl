#ifndef RPCCONNTHREAD_TMPL__
#define RPCCONNTHREAD_TMPL__

#include "fieldfinal.H"

template <typename cookie_t> void
rpcconnthread<cookie_t>::run() {
    peername peer(conn.peer());
    
    bool die;
    die = false;
    
    subscriber sub;
    subscription shutdownallsub(sub, shutdownall.pub);
    subscription shutdownonesub(sub, shutdownone.pub);
    iosubscription insub(sub, conn.fd.poll(POLLIN));
    iosubscription outsub(sub, conn.fd.poll(POLLOUT));
    while (!die) {
        fields::flush();
        auto r(sub.wait());
        if (r == &shutdownallsub) {
            if (shutdownall.ready()) die = true;
        } else if (r == &shutdownonesub) {
            if (shutdownone.ready()) die = true;
        } else if (r == &insub) {
            auto t(conn.incoming.receive(conn.fd));
            insub.rearm();
            if (t.isjust()) {
                t.just().warn("receiving from client " + fields::mk(peer));
                break; }
            while (runcommand(&die))
                ;
        } else if (r == &outsub) {
            if (conn.outgoing.empty()) {
                /* Happens on initial iteration.  Just ignore it. */
            } else {
                auto rr(conn.outgoing.send(conn.fd));
                if (rr.isjust()) {
                    rr.just().warn("sending to client " + fields::mk(peer));
                    break; } }
        } else {
            abort(); }
        if (!conn.outgoing.empty()) outsub.rearm(); }
    
    logmsg(loglevel::info, fields::mk("client thread finishing"));
    owner->dying.pushtail(this); }

template <typename cookie_t> bool
rpcconnthread<cookie_t>::runcommand(
    bool *die) {
    auto r(wireproto::rx_message::fetch(conn.incoming));
    if (r.isfailure()) {
        *die = r.failure() != error::underflowed;
        return false; }
    assert(r.success() != NULL);
    auto tag(r.success()->t);
    logmsg(loglevel::verbose, "run command " + fields::mk(tag));
    
    auto reg(owner->service->lookup(tag));
    
    auto res(reg.iface->message(*r.success(), ctxt, conn.outgoing));
    
    reg.reg->finished();

    if (res.isjust()) {
        wireproto::err_resp_message(*r.success(), res.just())
            .serialise(conn.outgoing); }
    r.success()->finish();
    return true; }

template <typename cookie_t> thread *
rpcconnthread<cookie_t>::thr() const {
    return thr_; }

template <typename cookie_t> orerror<rpcconnthread<cookie_t> *>
rpcconnthread<cookie_t>::spawn(
    rpcserver<cookie_t> *owner,
    socket_t fd,
    waitbox<bool> &localshutdown) {
    auto peer(fd.peer());
    if (peer.isfailure()) return peer.failure();
    auto res(new rpcconnthread(owner, fd, peer.success(), localshutdown));
    auto ctxt(owner->startconn(res->conn));
    if (ctxt.isfailure()) {
        logmsg(loglevel::failure,
               "connection from " + fields::mk(res->conn.peer()) +
               " rejected by implementation: " + fields::mk(ctxt.failure()));
        delete res;
        return ctxt.failure();
    }
    res->ctxt = ctxt.success();
    
    auto t(thread::spawn(res, &res->thr_,
                         "RPC client thread for " + fields::mk(fd.peer())));
    if (t.isjust()) {
        delete res;
        return t.just();
    } else {
        return res; } }

#endif /* !RPCCONNTHREAD_TMPL__ */
