#ifndef RPCCONNTHREAD_TMPL__
#define RPCCONNTHREAD_TMPL__

#include "fieldfinal.H"

template <typename cookie_t> void
rpcconnthread<cookie_t>::run(clientio io) {
    peername peer(conn.peer());
    
    bool die;
    die = false;
    
    auto newctxt(startconn_(io, conn));
    if (newctxt.isfailure()) {
        newctxt.failure().warn("acception connection from " + fields::mk(peer));
        die = true;
    } else {
        ctxt = newctxt.success(); }
    subscriber sub;
    subscription shutdownsub(sub, shutdown.pub);
    iosubscription insub(io, sub, conn.fd.poll(POLLIN));
    iosubscription outsub(io, sub, conn.fd.poll(POLLOUT));
    while (!die) {
        fields::flush();
        auto r(sub.wait());
        if (r == &shutdownsub) {
            if (shutdown.ready()) die = true;
        } else if (r == &insub) {
            auto t(conn.incoming.receive(io, conn.fd));
            insub.rearm();
            if (t.isjust()) {
                t.just().warn("receiving from client " + fields::mk(peer));
                break; }
            while (runcommand(&die))
                ;
        } else if (r == &outsub) {
            if (conn.outgoing.empty()) {
                /* Happens on initial iteration.  Just ignore it. */
            } else {
                auto rr(conn.outgoing.send(io, conn.fd));
                if (rr.isjust()) {
                    rr.just().warn("sending to client " + fields::mk(peer));
                    break; } }
        } else {
            abort(); }
        if (!conn.outgoing.empty()) outsub.rearm(); }
    
    logmsg(loglevel::info, fields::mk("client thread finishing"));
    endconn_(io, ctxt); }

template <typename cookie_t> bool
rpcconnthread<cookie_t>::runcommand(
    bool *die) {
    auto r(wireproto::rx_message::fetch(conn.incoming));
    if (r.isfailure()) {
        *die = r.failure() != error::underflowed;
        return false; }
    assert(r.success() != NULL);
    auto tag(r.success()->t);
    logmsg(loglevel::verbose, "run command " + fields::mk(tag));
    
    auto reg(service->lookup(tag));
    
    auto res(reg.iface->message(*r.success(), ctxt, conn.outgoing));
    
    reg.reg->finished();

    if (res.isjust()) {
        wireproto::err_resp_message(*r.success(), res.just())
            .serialise(conn.outgoing); }
    r.success()->finish();
    return true; }

template <typename cookie_t> thread *
rpcconnthread<cookie_t>::thr() const {
    return thr_; }

template <typename cookie_t> orerror<rpcconnthread<cookie_t> *>
rpcconnthread<cookie_t>::spawn(
    rpcservice<cookie_t> *service,
    startconn &sc,
    endconn &ec,
    socket_t fd,
    maybe<mutex_t::token> /* server threadmux.  Not actually needed by
                           * this function, just a warning that we're
                           * invoked holding the mux. */) {
    auto peer(fd.peer());
    if (peer.isfailure()) return peer.failure();
    auto res(new rpcconnthread(sc,
                               ec,
                               service,
                               fd,
                               peer.success()));
    
    auto t(thread::spawn(res, &res->thr_,
                         "RPC client thread for " + fields::mk(fd.peer())));
    if (t.isjust()) {
        delete res;
        return t.just();
    }
    return res; }

template <typename cookie_t> typename rpcconnthread<cookie_t>::startconn
rpcconnthread<cookie_t>::nostartconn;

template <typename cookie_t> typename rpcconnthread<cookie_t>::endconn
rpcconnthread<cookie_t>::noendconn;

#define RPCCONNTHREAD(ctxt)                                             \
    template class rpcconnthread<ctxt>;

#endif /* !RPCCONNTHREAD_TMPL__ */
