#ifndef RPCCONNTHREAD_TMPL__
#define RPCCONNTHREAD_TMPL__

#include "fieldfinal.H"

template <typename cookie_t> void
rpcconnthread<cookie_t>::run() {
    peername peer(conn.peer());
    
    bool die;
    die = false;
    
    subscriber sub;
    subscription shutdownsub(sub, shutdown.pub);
    {   subscription ctxtsub(sub, ctxt.pub);
        if (ctxt.ready()) ctxtsub.set();
        while (!die) {
            auto r(sub.wait());
            if (r == &shutdownsub) {
                if (shutdown.ready()) die = true;
            } else if (r == &ctxtsub) {
                break;
            } else {
                abort(); } } }
    iosubscription insub(sub, conn.fd.poll(POLLIN));
    iosubscription outsub(sub, conn.fd.poll(POLLOUT));
    while (!die) {
        fields::flush();
        auto r(sub.wait());
        if (r == &shutdownsub) {
            if (shutdown.ready()) die = true;
        } else if (r == &insub) {
            auto t(conn.incoming.receive(conn.fd));
            insub.rearm();
            if (t.isjust()) {
                t.just().warn("receiving from client " + fields::mk(peer));
                break; }
            while (runcommand(&die))
                ;
        } else if (r == &outsub) {
            if (conn.outgoing.empty()) {
                /* Happens on initial iteration.  Just ignore it. */
            } else {
                auto rr(conn.outgoing.send(conn.fd));
                if (rr.isjust()) {
                    rr.just().warn("sending to client " + fields::mk(peer));
                    break; } }
        } else {
            abort(); }
        if (!conn.outgoing.empty()) outsub.rearm(); }
    
    logmsg(loglevel::info, fields::mk("client thread finishing")); }

template <typename cookie_t> bool
rpcconnthread<cookie_t>::runcommand(
    bool *die) {
    auto r(wireproto::rx_message::fetch(conn.incoming));
    if (r.isfailure()) {
        *die = r.failure() != error::underflowed;
        return false; }
    assert(r.success() != NULL);
    auto tag(r.success()->t);
    logmsg(loglevel::verbose, "run command " + fields::mk(tag));
    
    auto reg(service->lookup(tag));
    
    auto res(reg.iface->message(*r.success(), ctxt.get(), conn.outgoing));
    
    reg.reg->finished();

    if (res.isjust()) {
        wireproto::err_resp_message(*r.success(), res.just())
            .serialise(conn.outgoing); }
    r.success()->finish();
    return true; }

template <typename cookie_t> thread *
rpcconnthread<cookie_t>::thr() const {
    return thr_; }

template <typename cookie_t> orerror<rpcconnthread<cookie_t> *>
rpcconnthread<cookie_t>::spawn(
    rpcserver<cookie_t> *owner,
    socket_t fd,
    mutex_t::token tok) {
    tok.formux(owner->mux);
    auto peer(fd.peer());
    if (peer.isfailure()) return peer.failure();
    auto res(new rpcconnthread(owner->service,
                               fd,
                               peer.success()));
    
    auto t(thread::spawn(res, &res->thr_,
                         "RPC client thread for " + fields::mk(fd.peer())));
    if (t.isjust()) {
        delete res;
        return t.just();
    }
    auto ctxt(owner->startconn(res->conn));
    if (ctxt.isfailure()) {
        logmsg(loglevel::failure,
               "connection from " + fields::mk(res->conn.peer()) +
               " rejected by implementation: " + fields::mk(ctxt.failure()));
        res->shutdown.set(true);
        res->thr_->join();
        delete res;
        return ctxt.failure();
    }
    res->ctxt.set(ctxt.success());
    owner->_startconn(res);
    return res; }

#endif /* !RPCCONNTHREAD_TMPL__ */
