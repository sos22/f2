#ifndef PARSERS_TMPL__
#define PARSERS_TMPL__

#include "filename.H"
#include "parsers.H"

template <typename rval>
parser<rval>::result::result(const rval &a, const char *b)
    : res(a), left(b) {}

#if 0
template <typename newtype, typename oldtype>
class mapparser : public parser<newtype> {
private: const parser<oldtype> &underlying;
private: std::function<newtype (const oldtype &)> mapper;
private: orerror<typename parser<newtype>::result> parse(
    const char *what) const {
    auto r1(underlying.parse(what));
    if (r1.isfailure()) return r1.failure();
    else return typename parser<newtype>::result(
        mapper(r1.success().res),
        r1.success().left); }
public:  mapparser(const parser<oldtype> &_underlying,
                   const std::function<newtype (const oldtype &)> &_mapper)
    : parser<newtype>(),
      underlying(_underlying),
      mapper(_mapper) {} };
template <typename oldtype> template <typename newtype>
parser<newtype> const &
parser<oldtype>::map(
    std::function<newtype (const oldtype &)> const &mapper) const {
    return *new mapparser<newtype, oldtype>(*this, mapper); }
#endif

template <typename r> orerror<r>
parser<r>::match(const string &what) const {
    auto r1(parse(what.c_str()));
    if (r1.isfailure()) return r1.failure();
    else if (r1.success().left[0] != '\0') return error::noparse;
    else return r1.success().res; }

#if 0
template <typename a, typename b>
class concatparser : public parser<pair<a, b> > {
private: const parser<a> &_a;
private: const parser<b> &_b;
private: orerror<typename parser<pair<a, b> >::result> parse(
    const char *what) const {
    auto r1(_a.parse(what));
    if (r1.isfailure()) return r1.failure();
    auto r2(_b.parse(r1.success().left));
    if (r2.isfailure()) return r2.failure();
    else return result(pair<a, b>(r1.success().res,
                                  r2.success().res),
                       r2.success().left); }
public:  concatparser(
    const parser<a> &__a,
    const parser<b> &__b)
    : _a(__a),
      _b(__b) {} };
#endif

template <typename rval, typename other> const parser<pair<rval, other> > &
parser<rval>::operator+(const parser<other> &o) {
    return *new concatparser(*this, o); }

template <typename a, typename b>
class alternateparser : public parser<either<a, b> > {
private: const parser<a> &_a;
private: const parser<b> &_b;
private: orerror<typename parser<either<a, b> >::result> parse(
    const char *what) const {
    auto r1(_a.parse(what));
    if (r1.issuccess()) return r1;
    else return _b.parse(what); }
public:  alternateparser(
    const parser<a> &__a,
    const parser<b> &__b)
    : _a(__a),
      _b(__b) {} };
template <typename rval, typename other> const parser<either<rval, other> > &
parser<rval>::operator|(const parser<other> &o) {
    return *new alternateparser(*this, o); }

template <typename t> class matchthenparse : public parser<t> {
private: const parser<void> &_match;
private: const parser<t> &_parse;
private: orerror<typename parser<t>::result> parse(
    const char *what) const {
    auto r1(_match.parse(what));
    if (r1.isfailure()) return r1.failure();
    else return _parse.parse(r1.success()); } }
template <typename t> const parser<t> &
parser<void>::operator+(const parser<t> &what) const {
    return *new matchthenparse(*this, what); }

template <typename t> class matchorparse : public parser<maybe<t> > {
private: const parser<void> &_match;
private: const parser<t> &_parse;
private: orerror<typename parser<t>::result> parse(
    const char *what) const {
    auto r1(_match.parse(what));
    if (r1.issuccess()) return result(Nothing, r1.success());
    auto r2(_parse.parse(what));
    if (r2.isfailure()) return r2.failure();
    else return result(r2.success().res, r2.success().left); } };
template <typename t> const parser<t> &
parser<void>::operator+(const parser<t> &what) const {
    return *new matchorparse(*this, what); }

template <typename t> orerror<typename parser<t>::result> parse(
    const char *buf) const {
    size_t l(strlen(what));
    if (strncmp(buf, what, l) == 0) return result(val, buf + l);
    else return error::noparse; }

template <typename r> orerror<typename parser<r>::result>
errparser<r>::parse(const char *) const {
    return e; };

#endif /* !PARSERS_TMPL__ */
