/* Client half of the event queue system.  The main guarantee an event
 * queue gives to its caller is that events are never dropped
 * silently: if the client connects at time A, the server generates an
 * event at time B and the client checks for events at time C, then
 * provided B is after A and C is sufficiently after B, C will either
 * receive the event or will receive an error indication.  The exact
 * meaning of ``sufficiently after'' is left unspecificied, beyond
 * specifying that the delay always be finite.  Note that the queue
 * can occasionally generate spurious errors, even when no events have
 * been dropped and there have been no ``actual'' errors, although we
 * obviously try to keep spurious errors sufficently rare not to
 * render the queue completely useless. */
#ifndef EQCLIENT_H__
#define EQCLIENT_H__

#include "clientio.H"
#include "eq.H"
#include "maybe.H"
#include "pubsub.H"
#include "timestamp.H"

class buffer;
class connpool;
template <typename> class nnp;
template <typename> class orerror;
class slavename;

/* Implementation detail of eqclient. */
class geneqclient {
private: class impl;
    friend class impl;
public:  impl &implementation();
private: const impl &implementation() const;
public:  void start(clientio);
public:  static orerror<nnp<geneqclient> > connect(
    clientio io,
    connpool &pool,
    const slavename &sn,
    const proto::eq::genname &,
    timestamp deadline);
public:  const publisher &pub() const;
public:  maybe<orerror<buffer> > pop();
public:  void destroy(clientio);
private: ~geneqclient(); };

template <typename t> class eqclient final : private geneqclient {
private: eqclient();

    /* Note that this cannot have any members, because its destructor
     * is never invoked. */

    /* ``Connect'' to a remote event queue.  The semi-reliability
     * guarantee only applies to events generated by the server after
     * this returns.  This always succeeds; errors are reported at the
     * first call to pop(). */
public:  static orerror<nnp<eqclient> > connect(
    clientio io,
    connpool &pool,
    const slavename &sn,
    const proto::eq::name<t> &queue,
    timestamp d) {
        auto r(geneqclient::connect(io, pool, sn, queue, d));
        if (r.isfailure()) return r.failure();
        else return _nnp(*static_cast<eqclient *>(&*r.success())); }

    /* Notified whenever pop() becomes non-Nothing. */
public:  const publisher &pub() const { return geneqclient::pub(); }

    /* Extract the next thing from the queue, without blocking, and
     * return Nothing if nothing is currently available.  Can also
     * return an error if the queue has failed.  Errors are sticky:
     * the only way to clear them is to tear the queue down and start
     * again. */
public:  maybe<orerror<t> > pop() {
        auto r(geneqclient::pop());
        if (r == Nothing) return Nothing;
        else if (r.just().isfailure()) {
            return maybe<orerror<t> >(r.just().failure()); }
        else {
            deserialise1 ds(r.just().success());
            return success(t(ds)); } }

    /* Blocking variant of pop().  Equivalent to calling pop()
     * repeatedly until it returns non-Nothing. */
public:  orerror<t> pop(clientio io) {
        maybe<orerror<t> > res(pop());
        if (res == Nothing) {
            subscriber sub;
            subscription ss(sub, pub());
            res = pop();
            while (res == Nothing) {
                sub.wait(io);
                res = pop(); } }
        return res.just(); }

    /* Tear down a queue client, discarding any pending events not yet
     * returned by pop(). */
public:  void destroy(clientio io) { geneqclient::destroy(io); }

    /* Never actually called: base class destructor is non-virtual. */
private: ~eqclient() = delete;
};

#endif /* !EQCLIENT_H__ */
