#ifndef THREAD2_TMPL__
#define THREAD2_TMPL__

#include "thread2.H"

#include <pthread.h>
#include <string.h>

#include "error.H"
#include "fields.H"

template <typename t>
pausedthread<t>::pausedthread(t *_inner)
    : inner_(_inner) {}

template <typename t> t *
pausedthread<t>::go() {
    auto res(inner_);
    thread2 *r(res);
    inner_ = NULL;
    r->go();
    return res; }

template <typename t> void
pausedthread<t>::destroy() {
    thread2 *i(inner_);
    assert(!i->started);
    inner_->join(clientio::CLIENTIO);
    inner_ = NULL; }

template <typename t, typename ... args> pausedthread<t> thread2::spawn(
    const fields::field &name,
    args &...params) {
    auto res = new t(constoken(name), params...);
    /* Check it derives from thread2. */
    thread2 *rr = res;
    (void)rr;
    return res; }

#endif /* !THREAD2_TMPL__ */
