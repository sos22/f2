#ifndef COMPUTE_H__
#define COMPUTE_H__

#include "either.H"
#include "job.H"
#include "jobname.H"
#include "jobresult.H"
#include "maybe.H"
#include "orerror.H"
#include "pair.H"

class deserialise1;
namespace fields { class field; }
class serialise1;

namespace proto {
namespace compute {
class tag {
private: unsigned v;
private: explicit tag(unsigned);
public:  explicit tag(deserialise1 &);
public:  void serialise(serialise1 &) const;
    /* Inputs: job, peername.
     * Outputs: proto::eq::eventid, tasktag.
     *
     * Starts a new task running on the slave.  The input peername is
     * a storage slave which holds the job.  The returned tasktag is a
     * unique identifier for this incarnation of the job.
     */
public:  static const tag start;
    /* Inputs: None
     * Outputs: proto::eq::eventid, list<jobstatus>
     *
     * Get status of all jobs running on this compute slave, plus the
     * event ID at which the snapshot was taken.  Note that there is
     * no way of querying a subset of the jobs; the assumption that
     * there are few enough running that that won't be needed.
     */
public:  static const tag enumerate;
    /* Inputs: jobname
     * Outputs: None
     *
     * Drop the results of a completed job from the job table.  Only
     * valid once the job has completed.
     */
public:  static const tag drop;
    
public:  bool operator==(tag o) const { return v == o.v; }
public:  bool operator!=(tag o) const { return v != o.v; } };

/* Unique identifier for a particular incarnation of a job.  Only
 * really useful for debugging; all of the interesting APIs are
 * job-oriented, rather than task-oriented. */
class tasktag {
private: unsigned long v;
private: explicit tasktag(unsigned long);
public:  explicit tasktag(deserialise1 &);
public:  void serialise(serialise1 &) const;
public:  const fields::field &field() const;
public:  static tasktag invent(); };

/* Current status of a job. */
class jobstatus {
public:  jobname name;
public:  tasktag tag;
    /* Either Nothing if the job's still running, or an error if F2
     * encountered an error, or the result of the job it it's finished
     * without generating an F2 error.  Note that F2 running the job
     * until the job itself generates an error counts as success at
     * this level. */
public:  maybe<orerror<jobresult> > result;
private: jobstatus(const jobname &,
                   tasktag,
                   const maybe<orerror<jobresult> > &);
public:  explicit jobstatus(deserialise1 &);
public:  void serialise(serialise1 &) const;
public:  static jobstatus running(const jobname &, tasktag);
public:  static jobstatus finished(const jobname &,
                                   tasktag,
                                   const orerror<jobresult> &);
public:  const fields::field &field() const; };

/* Events generated by compute slaves. */
class event {
private: typedef maybe<either<either<pair<jobname, tasktag>,
                                     jobstatus>,
                              jobstatus> > contentT;
private: contentT content;
private: event(const contentT &);
public:  void serialise(serialise1 &) const;
public:  explicit event(deserialise1 &);
public:  static event start(const jobname &jn, const tasktag &tag);
public:  static event finish(const jobstatus &);
public:  static event removed(const jobstatus &);
public:  static event flushed();
public:  const fields::field &field() const; }; } }

namespace fields {
static inline const field &mk(proto::compute::tasktag t) { return t.field(); }
static inline const field &mk(proto::compute::jobstatus t) {
    return t.field(); } }

#endif /* !COMPUTE_H__ */
