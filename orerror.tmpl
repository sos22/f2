#ifndef ORERROR_TMPL__
#define ORERROR_TMPL__

#include "either.tmpl"
#include "parsers.tmpl"

template <typename t>
orerror<t>::orerror(error e) : either<error, t>(Left(), e) {}

template <typename t>
orerror<t>::orerror(const t &x) : either<error, t>(Right(), x) {}

template <typename t>
orerror<t>::orerror(_Steal s, t &x) : either<error, t>(s, Right(), x) {}

template <typename t>
orerror<t>::orerror(_Steal s, orerror &o) : either<error, t>(s, o) {}

template <typename t>
orerror<t>::orerror(deserialise1 &ds) : either<error, t>(ds) {}

template <typename t> error
orerror<t>::failure() const {
    assert(this->isfailure());
    return this->left(); }

template <typename t> const t &
orerror<t>::fatal(const fields::field &f) const {
    if (this->isfailure()) this->failure().fatal(f);
    else return this->success(); }

template <typename t> const t &
orerror<t>::fatal(const char *f) const {
    if (this->isfailure()) this->failure().fatal(f);
    else return this->success(); }

template <typename t> bool
orerror<t>::operator==(const error &e) const {
    return this->isleft() && this->left() == e; }

template <typename t> bool
orerror<t>::operator==(const t &o) const {
    return this->isright() && this->right() == o; }

template <typename t> bool
orerror<t>::operator==(const orerror &o) const {
    return
        (this->isleft() && o.isleft() && this->left() == o.left()) ||
        (this->isright() && o.isright() && this->right() == o.right()); }

template <typename t> void
orerror<t>::operator=(const orerror &o) {
    if (o.isleft()) this->mkleft(o.left());
    else this->mkright(o.right()); }

template <typename t> const fields::field &
orerror<t>::field() const {
    if (isfailure()) return "<failed:" + failure().field() + ">";
    else return "<" + fields::mk(success()) + ">"; }

template <typename t> const ::parser<orerror<t> > &
orerror<t>::parser(const ::parser<t> &inner) {
    class innerP : public ::parser<orerror<t> > {
    public: typedef typename ::parser<orerror<t> >::result result;
    public: const ::parser<t> &inner;
    public: innerP(const ::parser<t> &_inner) : inner(_inner) {}
    public: orerror<result> parse(const char *what) const {
        auto r((("<failed:" + error::parser() + ">") |
                ("<" + inner + ">"))
               .parse(what));
        if (r.isfailure()) return r.failure();
        else if (r.success().res.isleft()) {
            return result(r.success().left, r.success().res.left()); }
        else {
            return result(r.success().left, r.success().res.right()); } } };
    return *new innerP(inner); }

template <typename t> const ::parser<orerror<t> > &
orerror<t>::parser() { return orerror<t>::parser(parsers::defaultparser<t>()); }

template <typename t> const t
orerror<t>::flatten() const {
    if (isfailure()) return failure();
    else if (success().isfailure()) return success().failure();
    else return success().success(); }

#endif /* !ORERROR_TMPL__ */
