#ifndef WIREPROTO_TMPL__
#define WIREPROTO_TMPL__

#include "fields.H"
#include "orerror.H"

#include "fieldfinal.H"

class quickcheck;

namespace wireproto {

struct bufslice {
public: const void *content;
public: const size_t sz;
public: bufslice(const void *_content, size_t _sz)
    : content(_content), sz(_sz) {}
};

template <typename typ> maybe<typ> deserialise(bufslice &slice);

template <typename typ> maybe<typ>
rx_message::getparam(parameter<typ> p) const
{
    unsigned x;
    for (x = 0; x < msg->nrparams && msg->idx[x].id != p.id; x++)
        ;
    if (x == msg->nrparams) return Nothing;
    bufslice slice((const void *)((unsigned long)msg + msg->idx[x].offset),
                   (x + 1 == msg->nrparams
                    ? msg->sz
                    : msg->idx[x+1].offset) - msg->idx[x].offset);
    return deserialise<typ>(slice);
}

template <typename nested> maybe<error>
rx_message::fetch(parameter<list<nested> > tmpl, list<nested> &out) const {
    out.flush();
    for (unsigned x = 0; x < msg->nrparams; x++) {
        if (msg->idx[x].id == tmpl.id) {
            bufslice slice(
                (const void *)((unsigned long)msg + msg->idx[x].offset),
                (x + 1 == msg->nrparams
                 ? msg->sz
                 : msg->idx[x+1].offset) - msg->idx[x].offset);
            auto r(deserialise<nested>(slice));
            if (r == Nothing) {
                out.flush();
                return error::invalidmessage; }
            out.pushtail(r.just()); } }
    return Nothing; }

template <typename nested> tx_message &
tx_message::addparam(parameter<list<nested> > tmpl, const list<nested> &val)
{
    for (auto it(val.start()); !it.finished(); it.next())
        addparam(parameter<nested>(tmpl), *it);
    return *this;
}

template <typename type> void
roundtrip(unsigned nr = 1000) {
    parameter<type> param(1);
    for (unsigned x = 0; x < nr; x++) {
        ::quickcheck q;
        type thing(q);
        ::buffer buf;
        auto qq(tx_message(msgtag(1))
                .addparam(param, thing)
                .serialise(buf));
        assert(qq == Nothing);
        auto r(rx_message::fetch(buf));
        auto rr(r.success().getparam(param));
        assert(rr.just() == thing); } }

}

namespace fields {
template <typename t> const field &
mk(const wireproto::parameter<t> &param)
{
    return "<param:" + mk(param.id) + ">";
}

}

#define __wireproto_wrapper_type(wrapper_type)                          \
    namespace wireproto {                                               \
        template <> tx_message &tx_message::addparam(                   \
            parameter<wrapper_type> tmpl,                               \
            const wrapper_type &val)                                    \
        {                                                               \
            val.addparam(tmpl, *this);                                  \
            return *this;                                               \
        }                                                               \
    }                                                                   \
    namespace fields {                                                  \
        template const field &mk(                                       \
            const wireproto::parameter<wrapper_type> &);                \
        template const field &mk(                                       \
            const maybe<wrapper_type> &);                               \
    }
#define wireproto_wrapper_type(wrapper_type)                            \
    __wireproto_wrapper_type(wrapper_type)                              \
    namespace wireproto {                                               \
        template <> maybe<wrapper_type>                                 \
        rx_message::getparam<wrapper_type>(parameter<wrapper_type> p) const \
        {                                                               \
            auto m(getparam(parameter<rx_message>(p)));                  \
            if (m == Nothing) return Nothing;                           \
            else return wrapper_type::fromcompound(m.just());           \
        }                                                               \
        template <> maybe<wrapper_type> deserialise(                    \
            wireproto::bufslice &slice) {                               \
            auto m(deserialise<rx_message>(slice));                     \
            if (!m) return Nothing;                                     \
            else return wrapper_type::fromcompound(m.just()); }         \
    }

#define wireproto_simple_wrapper_type(wrapper_type, wrapped_type, field) \
    namespace wireproto {                                               \
    template <> maybe<wrapper_type>                                     \
    rx_message::getparam(parameter<wrapper_type> p) const {             \
        auto m(getparam(parameter<wrapped_type>(p)));                   \
        if (m == Nothing) return Nothing;                               \
        else return wrapper_type(m.just()); }                           \
    template <> tx_message &                                            \
    tx_message::addparam(parameter<wrapper_type> p,                     \
                         const wrapper_type &val) {                     \
        return addparam(parameter<wrapped_type>(p),                     \
                        val.unwrap()); }                                \
    template <> maybe<wrapper_type>                                     \
    deserialise(bufslice &slice) {                                      \
        auto r(deserialise<wrapped_type>(slice));                       \
        if (r == Nothing) return Nothing;                               \
        else return wrapper_type::__fromwrapped__(r.just()); } }        \
    wrapper_type wrapper_type::__fromwrapped__(wrapped_type t) {        \
        return wrapper_type(t); }

#endif /* !WIREPROTO_H__ */
