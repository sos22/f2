#ifndef RPCSERVER_TMPL__
#define RPCSERVER_TMPL__

#include <sys/poll.h>
#include <string.h>

#include "fields.H"
#include "logging.H"
#include "peername.H"
#include "rpcconn.H"
#include "rpcconnthread.H"
#include "rpcservice.H"
#include "util.H"
#include "waitbox.H"
#include "waitqueue.H"

#include "list.tmpl"
#include "waitqueue.tmpl"
#include "rpcconnthread.tmpl"
#include "rpcregistration.tmpl"
#include "rpcservice.tmpl"

#include "fieldfinal.H"

template <typename cookie_t>
rpcserver<cookie_t>::rootthread::rootthread(
    rpcserver<cookie_t> *_owner)
    : threads(),
      threadsmux(),
      owner(_owner) {}

template <typename cookie_t> void
rpcserver<cookie_t>::rootthread::run() {
    subscriber sub;
    iosubscription socksub(sub, owner->sock.poll());
    subscription dyingsub(sub, owner->dying.pub);
    subscription shutdownsub(sub, owner->shutdown.pub);
    while (!owner->shutdown.ready() || !threads.empty()) {
        auto r(sub.wait());
        if (r == &shutdownsub) {
            if (!owner->shutdown.ready()) continue;
            logmsg(loglevel::info,
                   fields::mk("control interface received local shutdown"));
        } else if (r == &dyingsub) {
            if (owner->dying.empty()) continue;
            auto thr(owner->dying.pophead());
            logmsg(loglevel::info,
                   "control interface reaping client thread" +
                   fields::mk(*thr->thr()));
            thr->thr()->join();
            owner->endconn(thr->ctxt);
            auto token(threadsmux.lock());
            for (auto it(threads.start()); 1; it.next()) {
                assert(!it.finished());
                if (*it == thr) {
                    it.remove();
                    break;
                }
            }
            threadsmux.unlock(&token);
            delete thr;
        } else if (r == &socksub) {
            if (owner->shutdown.ready()) {
                /* We're shutting down, so go back to waiting without
                   accepting the new connection and without rearming
                   the subscription. */
                continue; }
            auto newfd(owner->sock.accept());
            socksub.rearm();
            if (newfd.isfailure())
                newfd.failure().fatal("accept on control interface");
            logmsg(loglevel::info,
                   "control interface accepting new client " +
                   fields::mk(newfd.success().peer()));
            auto token(threadsmux.lock());
            auto tr(rpcconnthread<cookie_t>::spawn(owner,
                                                   newfd.success(),
                                                   owner->shutdown));
            if (tr.isfailure()) {
                error::from_errno().warn(
                    "Cannot build thread for new client " +
                    fields::mk(newfd.success().peer()));
                newfd.success().close();
            } else {
                threads.pushhead(tr.success());
            }
            threadsmux.unlock(&token);
        } else {
            abort(); } }
    
    assert(threads.empty());
    assert(owner->shutdown.ready());
    assert(owner->dying.empty());
    return; }

template <typename cookie_t>
rpcserver<cookie_t>::rpcserver()
    : service(new rpcservice<cookie_t>()),
      mux(),
      shutdown(),
      dying(),
      sock(),
      roothandle(NULL),
      root(this) {}

template <typename cookie_t> maybe<error>
rpcserver<cookie_t>::start(const peername &p, const fields::field &name) {
    assert(!roothandle);
    auto sl(socket_t::listen(p));
    if (sl.isfailure()) return sl.failure();
    sock = sl.success();
    auto threaderr(thread::spawn(
                       &root, &roothandle, name));
    if (threaderr.isjust()) sock.close();
    return threaderr; }

template <typename cookie_t> peername
rpcserver<cookie_t>::localname() const {
    return sock.localname(); }

template <typename cookie_t> void
rpcserver<cookie_t>::killconn(rpcconn &conn) {
    auto token(root.threadsmux.lock());
    for (auto it(root.threads.start()); !it.finished(); it.next()) {
        if (&conn == &(*it)->conn) {
            (*it)->shutdownone.set(true);
            root.threadsmux.unlock(&token);
            return; } }
    root.threadsmux.unlock(&token);
    abort(); }

template <typename cookie_t> void
rpcserver<cookie_t>::stop() {
    if (roothandle == NULL) return;
    shutdown.set(true);
    roothandle->join();
    roothandle = NULL;
    service->destroy();
    service = NULL; }

template <typename cookie_t> void
rpcserver<cookie_t>::destroy() {
    stop();
    delete this; }

template <typename cookie_t>
rpcserver<cookie_t>::~rpcserver() {
    assert(!roothandle); }

#define RPCSERVER(ctxt)                                                 \
    template class rpcserver<ctxt>;                                     \
    template class rpcservice<ctxt>;                                    \
    template class rpcconnthread<ctxt>;                                 \
    template class rpcregistration<ctxt>;                               \
    template class rpcinterface<ctxt>;                                  \
    template class list<rpcinterface<ctxt> *>;                          \
    template class list<rpcregistration<ctxt> *>;                       \
    template class list<rpcconnthread<ctxt> *>;                         \
    template class waitqueue<rpcconnthread<ctxt> *>;

#endif /* !RPCSERVER_TMPL__ */
