#ifndef RPCSERVER_TMPL__
#define RPCSERVER_TMPL__

#include <sys/poll.h>
#include <string.h>

#include "fields.H"
#include "logging.H"
#include "peername.H"
#include "rpcconn.H"
#include "util.H"
#include "waitbox.H"
#include "waitqueue.H"

#include "list.tmpl"
#include "waitqueue.tmpl"

template <typename cookie_t>
rpcregistration<cookie_t>::rpcregistration(
    rpcserver<cookie_t> *_owner)
    : mux(),
      idle(mux),
      owner(_owner),
      content(),
      outstanding(0) {}

template <typename cookie_t> void
rpcregistration<cookie_t>::start()
{
    auto token(mux.lock());
    outstanding++;
    mux.unlock(&token);
}

template <typename cookie_t> void
rpcregistration<cookie_t>::finished()
{
    auto token(mux.lock());
    assert(outstanding > 0);
    outstanding--;
    if (outstanding == 0)
        idle.broadcast(token);
    mux.unlock(&token);
}

template <typename cookie_t> void
rpcregistration<cookie_t>::destroy() {
    /* Stop further invocations */
    owner->deregister(this);
    /* Wait for extant invocations to finish */
    auto token(mux.lock());
    while (outstanding != 0)
        token = idle.wait(&token);
    mux.unlock(&token);
    /* We're done. */
    content.flush();
    delete this; }

template <typename cookie_t>
rpcinterface<cookie_t>::rpcinterface(
    wireproto::msgtag _tag)
    : tag(_tag) {}

template <typename cookie_t>
class rpcserver<cookie_t>::connectionthread : threadfn {
private: thread *thr_;
private: rpcserver *owner;
private: socket_t fd;
private: waitbox<bool> &shutdown;
private: void run();
private: connectionthread(
    rpcserver *_owner,
    socket_t _fd,
    waitbox<bool> &_shutdown)
    : owner(_owner), fd(_fd), shutdown(_shutdown) {}
private: bool runcommand(rpcconn &conn,
                         cookie_t ctxt,
                         bool *die);
public:  thread *thr() const;
public:  static orerror<connectionthread *> spawn(
    rpcserver *owner,
    socket_t fd,
    waitbox<bool> &);
};

template <typename cookie_t> bool
rpcserver<cookie_t>::connectionthread::runcommand(
    rpcconn &conn,
    cookie_t ctxt,
    bool *die) {
    auto r(wireproto::rx_message::fetch(conn.incoming));
    if (r.isfailure()) {
        *die = r.failure() != error::underflowed;
        return false; }
    assert(r.success() != NULL);
    auto tag(r.success()->t);
    logmsg(loglevel::verbose, "run command " + fields::mk(tag));
    
    auto token(owner->mux.lock());
    auto reg(owner->unknownregistration);
    rpcinterface<cookie_t> *iface(&owner->unknowninterface);
    for (auto it(owner->registrations.start());
         !it.finished();
         it.next()) {
        for (auto it2((*it)->content.start());
             !it2.finished();
             it2.next()) {
            if ((*it2)->tag == tag) {
                reg = *it;
                iface = *it2;
                break; } } }
    reg->start();
    owner->mux.unlock(&token);
    
    auto res(iface->message(*r.success(), ctxt, conn.outgoing));
    
    reg->finished();

    if (res.isjust()) {
        wireproto::err_resp_message(*r.success(), res.just())
            .serialise(conn.outgoing); }
    r.success()->finish();
    return true; }

template <typename cookie_t> void
rpcserver<cookie_t>::connectionthread::run() {
    rpcconn conn(fd);
    peername peer(conn.peer());
    
    bool die;
    die = false;
    auto ctxt(owner->startconn(conn));
    if (ctxt.isfailure()) {
        logmsg(loglevel::failure,
               "connection from " + fields::mk(peer) +
               " rejected by implementation: " + fields::mk(ctxt.failure()));
        die = true;
    } else {
        logmsg(loglevel::info, "start client thread " + fields::mk(peer)); }
    
    subscriber sub;
    subscription shutdownsub(sub, shutdown.pub);
    iosubscription insub(sub, fd.poll(POLLIN));
    iosubscription outsub(sub, fd.poll(POLLOUT));
    while (!die) {
        fields::flush();
        auto r(sub.wait());
        if (r == &shutdownsub) {
            if (shutdown.ready()) die = true;
        } else if (r == &insub) {
            auto t(conn.incoming.receive(fd));
            insub.rearm();
            if (t.isjust()) {
                t.just().warn("receiving from client " + fields::mk(peer));
                break; }
            while (runcommand(conn, ctxt.success(), &die))
                ;
        } else if (r == &outsub) {
            if (conn.outgoing.empty()) {
                /* Happens on initial iteration.  Just ignore it. */
            } else {
                auto rr(conn.outgoing.send(fd));
                if (rr.isjust()) {
                    rr.just().warn("sending to client " + fields::mk(peer));
                    break; } }
        } else {
            abort(); }
        if (!conn.outgoing.empty()) outsub.rearm(); }
    
    logmsg(loglevel::info, fields::mk("client thread finishing"));
    fd.close();
    owner->dying.pushtail(this); }

template <typename cookie_t> thread *
rpcserver<cookie_t>::connectionthread::thr() const {
    return thr_; }

template <typename cookie_t>
orerror<class rpcserver<cookie_t>::connectionthread *>
rpcserver<cookie_t>::connectionthread::spawn(
    rpcserver<cookie_t> *owner,
    socket_t fd,
    waitbox<bool> &localshutdown) {
    auto res(new connectionthread(owner, fd, localshutdown));
    auto t(thread::spawn(res, &res->thr_,
                         "RPC client thread for " + fields::mk(fd.peer())));
    if (t.isjust()) {
        delete res;
        return t.just();
    } else {
        return res; } }

template <typename cookie_t> void
rpcserver<cookie_t>::rootthread::run() {
    list<connectionthread *> threads;
    subscriber sub;
    iosubscription socksub(sub, owner->sock.poll());
    subscription dyingsub(sub, owner->dying.pub);
    subscription shutdownsub(sub, owner->shutdown.pub);
    while (1) {
        auto r(sub.wait());
        if (r == &shutdownsub) {
            if (!owner->shutdown.ready()) continue;
            logmsg(loglevel::info,
                   fields::mk("control interface received local shutdown"));
            /* No longer care about shutdown events */
            shutdownsub.detach();
            /* Exit once the threads list goes empty */
            if (threads.empty())
/**/            break;
        } else if (r == &dyingsub) {
            if (owner->dying.empty()) continue;
            auto thr(owner->dying.pophead());
            logmsg(loglevel::info,
                   "control interface reaping client thread" +
                   fields::mk(*thr->thr()));
            thr->thr()->join();
            for (auto it(threads.start()); 1; it.next()) {
                assert(!it.finished());
                if (*it == thr) {
                    it.remove();
                    break;
                }
            }
            delete thr;
            /* If that was the last thread then we can safely shut down */
            if (threads.empty() && owner->shutdown.ready())
/**/            break;
        } else if (r == &socksub) {
            if (owner->shutdown.ready()) continue;
            auto newfd(owner->sock.accept());
            socksub.rearm();
            if (newfd.isfailure())
                newfd.failure().fatal("accept on control interface");
            logmsg(loglevel::info,
                   "control interface accepting new client " +
                   fields::mk(newfd.success().peer()));
            auto tr(connectionthread::spawn(owner,
                                            newfd.success(),
                                            owner->shutdown));
            if (tr.isfailure()) {
                error::from_errno().warn(
                    "Cannot build thread for new client " +
                    fields::mk(newfd.success().peer()));
                newfd.success().close();
            } else {
                threads.pushhead(tr.success());
            }
        } else {
            abort(); } }
    
    assert(threads.empty());
    assert(owner->shutdown.ready());
    assert(owner->dying.empty());
    return; }

template <typename cookie_t>
rpcserver<cookie_t>::rootthread::rootthread(
    rpcserver<cookie_t> *_owner)
    : owner(_owner) {}

template <typename cookie_t>
rpcserver<cookie_t>::unknowniface::unknowniface()
    : rpcinterface<cookie_t>(wireproto::msgtag(0)) {}

template <typename cookie_t> maybe<error>
rpcserver<cookie_t>::unknowniface::message(
    const wireproto::rx_message &msg,
    cookie_t,
    buffer &) {
    logmsg(loglevel::failure,
           "Received an unrecognised message type " + fields::mk(msg.t));
    return error::unrecognisedmessage; }

template <typename cookie_t>
rpcserver<cookie_t>::~rpcserver() {
    assert(!roothandle);
    assert(unknownregistration->outstanding == 0);
    unknownregistration->destroy();
    assert(registrations.empty()); }

template <typename cookie_t> void
rpcserver<cookie_t>::deregister(rpcregistration<cookie_t> *what)
{
    auto token(mux.lock());
    for (auto it(registrations.start()); !it.finished(); it.next()) {
        if (*it == what) {
            it.remove();
            mux.unlock(&token);
            return; } }
    mux.unlock(&token);
    abort(); }

template <typename cookie_t>
rpcserver<cookie_t>::rpcserver()
    : mux(),
      registrations(),
      shutdown(),
      dying(),
      sock(),
      roothandle(NULL),
      root(this),
      unknowninterface(),
      unknownregistration(registeriface(unknowninterface)) {}

template <typename cookie_t> rpcregistration<cookie_t> *
rpcserver<cookie_t>::registeriface(
    rpcinterface<cookie_t> &ri) {
    return registeriface(multiregistration().add(ri)); }

template <typename cookie_t> typename rpcserver<cookie_t>::multiregistration &
rpcserver<cookie_t>::multiregistration::add(
    rpcinterface<cookie_t> &ri) {
    content.pushtail(&ri);
    return *this; }

template <typename cookie_t>
rpcserver<cookie_t>::multiregistration::~multiregistration() {
    content.flush(); }

template <typename cookie_t> rpcregistration<cookie_t> *
rpcserver<cookie_t>::registeriface(const multiregistration &mr) {
    auto res(new class rpcregistration<cookie_t>(this));
    auto token(mux.lock());
    for (auto it1(mr.content.start()); !it1.finished(); it1.next()) {
        for (auto it2(registrations.start()); !it2.finished(); it2.next()) {
            for (auto it3((*it2)->content.start());
                 !it3.finished();
                 it3.next()) {
                assert((*it3)->tag != (*it1)->tag); } }
        res->content.pushtail(*it1); }
    registrations.pushtail(res);
    mux.unlock(&token);
    return res;
}

template <typename cookie_t> maybe<error>
rpcserver<cookie_t>::start(const peername &p, const fields::field &name)
{
    assert(!roothandle);
    assert(unknownregistration);
    
    auto sl(socket_t::listen(p));
    if (sl.isfailure()) return sl.failure();
    
    maybe<error> threaderr(Nothing);
    sock = sl.success();
    
    threaderr = thread::spawn(
        &root, &roothandle, name);
    if (threaderr.isjust()) sock.close();
    return threaderr; }

template <typename cookie_t> peername
rpcserver<cookie_t>::localname() const {
    return sock.localname(); }

template <typename cookie_t> void
rpcserver<cookie_t>::stop() {
    if (roothandle == NULL) return;
    shutdown.set(true);
    roothandle->join();
    roothandle = NULL; }

template <typename cookie_t> void
rpcserver<cookie_t>::destroy() {
    stop();
    delete this; }

#define RPCSERVER(ctxt)                                                 \
    template class rpcserver<ctxt>;                                     \
    template class rpcregistration<ctxt>;                               \
    template class rpcinterface<ctxt>;                                  \
    template class list<rpcinterface<ctxt> *>;                          \
    template class list<rpcregistration<ctxt> *>;                       \
    template class list<rpcserver<ctxt>::connectionthread *>;           \
    template class waitqueue<rpcserver<ctxt>::connectionthread *>;

#endif /* !RPCSERVER_TMPL__ */
