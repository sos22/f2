#ifndef RPCSERVER_TMPL__
#define RPCSERVER_TMPL__

#include "rpcserver.H"
#include "socket.H"

template <typename conn_t>
rpcserver<conn_t>::connsub::connsub(subscriber &_sub, conn_t *_conn)
    : subscription(_sub, _conn->deathpublisher()),
      conn(_conn) {
    if (_conn->hasdied() != Nothing) set(); }

template <typename conn_t> void
rpcserver<conn_t>::run(clientio io) {
    list<connsub *> threads;
    subscriber sub;
    subscription shutdownsub(sub, shutdown.pub);
    iosubscription ios(io, sub, sock.poll());

    while (!shutdown.ready() || !threads.empty()) {
        auto s = sub.wait();
        if (s == &shutdownsub) {
            shutdownsub.detach();
            for (auto it(threads.start()); !it.finished(); it.next()) {
                (*it)->conn->teardown(); }
        } else if (s == &ios) {
            /* Accept a new incoming connection */
            auto newsock(sock.accept());
            ios.rearm();
            if (newsock.isfailure()) {
                newsock.failure().warn("accepting incoming connection");
                continue; }
            if (shutdown.ready()) {
                newsock.success().close();
                /* Don't rearm, so we don't try and accept any more
                 * connections. */
                continue; }
            auto conn(accept(newsock.success()));
            if (conn.isfailure()) {
                conn.failure().warn(
                    "derived class rejected incoming connection");
                newsock.success().close();
                continue; }
            threads.pushtail(new connsub(sub, conn.success()));
        } else {
            /* Must have been a connection sub. */
            auto cs(static_cast<connsub *>(s));
            auto death(cs->conn->hasdied());
            if (!death) continue;
            /* Connection has died.  Finish tearing it down. */
            bool found = false;
            for (auto it(threads.start()); !it.finished(); it.next()) {
                if (*it == cs) {
                    found = true;
                    it.remove();
                    break; } }
            assert(found);
            conn_t *conn = cs->conn;
            delete cs;
            conn->destroy(death.just()); } } }

template <typename conn_t>
rpcserver<conn_t>::rpcserver()
    : thr(NULL),
      shutdown(),
      sock() {}

template <typename conn_t> maybe<error>
rpcserver<conn_t>::listen(const peername &p) {
    auto s(socket_t::listen(p));
    if (s.isfailure()) return s.failure();
    sock = s.success();
    auto spawnres(thread::spawn(this, &thr, "root " + fields::mk(p)));
    if (spawnres.isjust()) {
        sock.close();
        return spawnres.just(); }
    return Nothing; }

template <typename conn_t> void
rpcserver<conn_t>::destroy(clientio io) {
    assert(thr);
    shutdown.set(true);
    thr->join(io);
    thr = NULL;
    sock.close();
    delete this; }

template <typename conn_t>
rpcserver<conn_t>::~rpcserver() {
    assert(thr == NULL); }

#endif /* !RPCSERVER_TMPL__ */
