#ifndef MAYBE_TMPL__
#define MAYBE_TMPL__

#include "parsers.H"
#include "serialise.H"

template <typename t>
maybe<t>::maybe(quickcheck &o)
    : _isnothing(o) {
    if (!isnothing()) new (&content) t(o); }

template <typename t> const fields::field &
maybe<t>::field() const {
    if (isnothing()) return fields::mk("Nothing");
    else return "<" + just().field() + ">"; }

template <typename t> template <typename ... args> void
maybe<t>::mkjust(args &&...params) {
    if (isjust()) just().~t();
    _isnothing = false;
    ::new (&content) t(std::forward<args>(params)...); }

template <typename t> void
maybe<t>::serialise(serialise1 &s) const {
    s.push(_isnothing);
    if (isjust()) s.push(just()); }

template <typename t>
maybe<t>::maybe(deserialise1 &ds)
    : _isnothing(ds) {
    if (!_isnothing) new (&content) t(ds); }

template <typename t> void
maybe<t>::operator=(deserialise1 &ds) {
    bool newisnothing(ds);
    if (newisnothing) {
        if (isnothing()) { }
        else {
            content.~t();
            _isnothing = true; } }
    else {
        if (isjust()) content = ds;
        else {
            new (&content) t(ds);
            _isnothing = false; } } }

namespace parsers {
template <typename t> const parser<maybe<t> > &
_maybe(const parser<t> &underlying) {
    return strmatcher("Nothing", maybe<t>(Nothing)) ||
        ("<" + underlying + ">").map<maybe<t> >(
            [] (const t &x) { return maybe<t>(x); }); } }

#endif /* !MAYBE_TMPL__ */
